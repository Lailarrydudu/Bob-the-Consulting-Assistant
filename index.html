<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consulting Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Import Georgia (Body) and Roboto Slab (Buttons) */
        @import url('https://fonts.googleapis.com/css2?family=Georgia:wght@400;700&family=Roboto+Slab:wght=700&display=swap');
        
        body {
            /* Main body and response content remains Georgia */
            font-family: 'Georgia', sans-serif;
            background-color: #111827; /* Tailwind gray-900 equivalent */
        }
        
        /* * Main Title: Smaller font, centered, bold. 
         * We'll use this for the H1 tag generated by Markdown's '#' 
         */
        .ai-response-content h1 {
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 1rem;
        }
        
        /* * Key Sections: Smaller font than the title, bold, no bullet point. 
         * We'll use this for the H2 tag generated by Markdown's '##' 
         */
        .ai-response-content h2 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #bef264 !important;
        }
        
        /* * Sub-sections within a section. 
         * We'll use this for the H3 tag generated by Markdown's '###' 
         */
        .ai-response-content h3 {
            font-size: 1.1rem; /* Slightly smaller for better hierarchy */
            font-weight: 700;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: #facc15 !important;
        }
        
        /* * Points in Sections: Bold, smaller than sections, larger than content. 
         * Markdown wraps these in a `<strong>` tag. 
         */
        .ai-response-content strong {
            font-size: 1rem;
            font-weight: 700;
            display: block; 
            margin-bottom: 0.25rem; 
            color: #facc15 !important;
        }
        
        /* Ensure bulleted lists are styled correctly and have a top margin */
        .ai-response-content ul {
            list-style-type: disc;
            padding-left: 2rem;
            margin-top: 0.5rem; /* Reduced margin since the strong tag now has margin-bottom */
        }
        
        /* Add a bottom margin to each list item for more spacing */
        .ai-response-content li {
            margin-bottom: 1.0rem;
        }
        
        /* Basic table styling for clarity */
        .ai-response-content table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        .ai-response-content th, .ai-response-content td {
            border: 1px solid #d1d5db; /* Lighter border for contrast on dark background */
            padding: 0.75rem;
            text-align: left;
            width: 33%; 
        }
        
        .ai-response-content th {
            /* Darker table header background */
            background-color: #374151; /* Tailwind gray-700 equivalent */
            font-weight: 700;
            color: #f3f4f6;
        }
        
        .ai-response-content td {
            background-color: #1f2937; /* Tailwind gray-800 equivalent */
        }
        .main-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #f3f4f6; /* Tailwind gray-100 equivalent */
        }
        
        .sub-title {
            font-size: 1.125rem;
            color: #d1d5db; /* Tailwind gray-300 equivalent */
            margin-top: 0.25rem;
        }
        
        /* === Custom Button Style (Main Dropdowns) === */
        .prompt-btn, .dropdown-btn {
            /* --- MODIFIED FONT FAMILY, SIZE, AND WEIGHT --- */
            font-family: 'Roboto Slab', serif; 
            font-size: 0.8125rem; 
            font-weight: 700; 
            /* ----------------------------------------------- */
            
            /* Base styles */
            padding-left: 0.75rem;
            padding-right: 0.75rem;
            padding-top: 0.5rem; 
            padding-bottom: 0.5rem; 
            color: #065f46; /* Text-emerald-800 */
            background-color: #ecfdf5; /* Bg-emerald-50 (light emerald) */
            border-radius: 0.75rem; /* Rounded-xl */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06); /* Shadow-lg */
            
            /* Border */
            border-width: 2px; 
            border-color: #34d399; /* Tailwind emerald-400 for better visibility */
            
            /* Sizing and alignment */
            width: 11rem; /* Fixed width for consistent size (w-44) */
            height: 3rem; /* Fixed height for consistent size (h-12) */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: normal;
                        
            /* Hover and transition effects */
            transition: all 0.2s ease-in-out;
            
            /* Ensure dropdown buttons inherit base style but can be overridden */
            cursor: pointer;
        }
        
        .prompt-btn:hover, .dropdown-btn:hover {
            background-color: #d1fae5; /* Hover:bg-emerald-100 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); /* Hover:shadow-xl */
            transform: translateY(-2px); /* Subtle lift effect */
        }
        
        /* Added active state for a physical "press" effect */
        .prompt-btn:active, .dropdown-btn:active {
            border-color: #10b981; /* Tailwind emerald-600 */
            border-width: 3px; 
            transform: translateY(0); 
            box-shadow: none; 
        }
        /* === Custom Button Style (Sub-Menu Buttons) === */
        .sub-menu-btn {
            /* Define styles for individual, stacked buttons */
            background-color: #303030; /* Charcoal Grey */
            color: #f3f4f6; /* Tailwind gray-100 */
            width: 100%;
            text-align: left;
            padding: 0.5rem 1rem; /* py-2 px-4 */
            font-size: 0.875rem; /* text-sm */
            transition: all 0.15s ease-in-out;
            font-family: 'Georgia', sans-serif;
            cursor: pointer;
            
            /* Key changes for individual button look */
            border: 1px solid #d1d5db; /* Light Grey (Tailwind gray-300) */
            border-radius: 0.5rem; /* rounded-lg */
            margin-bottom: 0.25rem; /* space between buttons */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);
        }
        
        .sub-menu-btn:hover {
            background-color: #4a4a4a; /* Slightly lighter Charcoal hover */
            transform: scale(1.01);
        }
        /* Ensure the last button doesn't have extra margin at the bottom */
        .sub-menu-btn:last-child {
            margin-bottom: 0;
        }
        /* Custom styles for the dynamic textarea */
        #userInput {
            /* Set initial row size and ensure dynamic growth */
            line-height: 1.5; 
            overflow-y: hidden; /* Hide scrollbar unless max height is reached */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            resize: none; /* Prevent manual resizing */
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-900">
    <div class="bg-gray-800 text-gray-100 rounded-2xl shadow-xl w-full max-w-2xl p-6 md:p-8">
        <div class="flex items-center space-x-4 mb-6">
            <div class="p-3 bg-emerald-100 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" fill="#10b981" viewBox="0 0 24 24" stroke-width="1.5" stroke="#10b981" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.225 3.658a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.6l-4.725-2.885a.563.563 0 00-.582 0l-4.725 2.885a.562.562 0 01-.84-.6l1.285-5.385a.562.562 0 00-.182-.557L3.991 10.49a.562.562 0 01.32-.988l5.518-.442a.563.563 0 00.475-.345l2.125-5.111z" />
                </svg>
            </div>
            <div>
                <h1 class="main-title">Bob, Your Consulting Assistant</h1>
                <p class="sub-title">You ask. Bob answers.</p>
            </div>
        </div>
        
        <div class="mb-6">
            <label for="apiKeyInput" class="block text-sm font-medium text-gray-100 mb-1">Enter your Gemini API Key:</label>
            <input type="password" id="apiKeyInput" class="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-emerald-500 bg-gray-700 text-white" placeholder="Paste your API key here...">
        </div>
        
        <div class="flex justify-between mb-4">
            
            <div class="grid grid-cols-2 gap-4">
                
                <div class="flex flex-col gap-4">
                    <div class="relative">
                        <button id="initialSetupDropdownBtn" class="dropdown-btn flex items-center justify-center">
                            Initial Setup
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div id="initialSetupMenu" class="absolute hidden top-full mt-2 w-56 bg-gray-800 rounded-lg shadow-2xl z-10 border border-emerald-500 p-2">
                            </div>
                    </div>
                    <div class="relative">
                        <button id="solutionDesignDropdownBtn" class="dropdown-btn flex items-center justify-center">
                            Solution Design
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div id="solutionDesignMenu" class="absolute hidden top-full mt-2 w-56 bg-gray-800 rounded-lg shadow-2xl z-10 border border-emerald-500 p-2">
                            </div>
                    </div>
                </div>
                
                <div class="flex flex-col gap-4">
                    <div class="relative">
                        <button id="analysisDropdownBtn" class="dropdown-btn flex items-center justify-center">
                            Analysis
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div id="analysisMenu" class="absolute hidden top-full mt-2 w-56 bg-gray-800 rounded-lg shadow-2xl z-10 border border-emerald-500 p-2">
                            </div>
                    </div>
                    <div class="relative">
                        <button id="executionDropdownBtn" class="dropdown-btn flex items-center justify-center">
                            Execution
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                        <div id="executionMenu" class="absolute hidden top-full mt-2 w-56 bg-gray-800 rounded-lg shadow-2xl z-10 border border-emerald-500 p-2">
                            </div>
                    </div>
                </div>
            </div> 

                <!-- Action Buttons Column (Top-Right) -->
            <div class="flex flex-col gap-4 items-end">
                <!-- My Prompts Button with Dropdown -->
                <div class="relative w-48">
                    <button id="myPromptsDropdownBtn" class="w-full px-3 py-1.5 bg-gray-400 text-white rounded-lg hover:bg-gray-500 transition duration-200 inline-flex items-center justify-center font-bold text-xs">
                        My Prompts
                        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="myPromptsMenu" class="absolute hidden top-full mt-2 w-56 bg-gray-800 rounded-lg shadow-2xl z-10 border border-emerald-500 p-2 right-0">
                    </div>
                </div>

                <!-- Generate Takeaways Button -->
                <button id="generateTakeawaysBtn" class="w-48 px-3 py-1.5 bg-gray-400 text-white rounded-lg hover:bg-gray-500 transition duration-200 font-bold text-xs">
                    Generate Takeaways
                </button>

                <!-- Run Workflow Button with Dropdown -->
                <div class="relative w-48">
                    <button id="workflowBtn" class="w-full px-3 py-1.5 bg-gray-400 text-white rounded-lg hover:bg-gray-500 transition duration-200 font-bold text-xs inline-flex items-center justify-center">
                        Run Workflow
                        <svg class="w-3 h-3 ml-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="workflowMenu" class="absolute hidden top-full right-0 mt-2 w-64 bg-gray-800 rounded-lg shadow-2xl z-10 border border-green-500 p-2">
                        <button class="workflow-option w-full text-left px-3 py-2 text-sm text-gray-100 hover:bg-gray-700 rounded" data-workflow="market-entry-strategy">
                            Market Entry Strategy
                        </button>
                        <button class="workflow-option w-full text-left px-3 py-2 text-sm text-gray-100 hover:bg-gray-700 rounded" data-workflow="business-health-check">
                            Business Health Check
                        </button>
                        <button class="workflow-option w-full text-left px-3 py-2 text-sm text-gray-100 hover:bg-gray-700 rounded" data-workflow="competitive-analysis">
                            Competitive Analysis
                        </button>
                    </div>
                </div>

                <!-- Export Chat Button -->
                <button id="exportBtn" class="w-48 px-3 py-1.5 bg-gray-400 text-white rounded-lg hover:bg-gray-500 transition duration-200 font-bold text-xs">
                    Export Chat
                </button>
            </div>
        </div> 
        
                <!-- Chat Area -->
        <div id="chatArea" class="space-y-4 max-h-96 overflow-y-auto mb-4">
        </div>

        
                <!-- Greeting Message and Clear Chat Button -->
        <div class="flex justify-between items-start mb-4">
            <div class="bg-emerald-100 text-emerald-700 rounded-xl p-3 max-w-sm shadow-md">
                Hi there! I'm Bob. How can I assist you today?
            </div>
            <button id="clearChatBtn" class="px-3 py-1.5 bg-gray-400 text-white rounded-lg hover:bg-gray-500 transition duration-200 font-bold text-xs border-2 border-red-500">Clear Chat</button>
        </div>

        
        <div class="flex items-center space-x-2">
            <textarea id="userInput" placeholder="Ask a question... (Enter to Send, Shift + Enter for Newline)" rows="1" class="flex-grow px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-emerald-500 bg-gray-700 text-white resize-none overflow-y-hidden"></textarea>
            <button id="sendButton" class="px-6 py-2 bg-emerald-600 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-emerald-500 disabled:bg-emerald-300 disabled:cursor-not-allowed" >Send</button>
        </div>
    </div>
    
    <script>
        (function() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const sendButton = document.getElementById('sendButton');
            const userInput = document.getElementById('userInput');
            const chatArea = document.getElementById('chatArea');
            const clearChatBtn = document.getElementById('clearChatBtn');
            const generateTakeawaysBtn = document.getElementById('generateTakeawaysBtn');

            // DROPDOWN ELEMENTS
            const initialSetupDropdownBtn = document.getElementById('initialSetupDropdownBtn');
            const initialSetupMenu = document.getElementById('initialSetupMenu');
            const analysisDropdownBtn = document.getElementById('analysisDropdownBtn');
            const analysisMenu = document.getElementById('analysisMenu');
            const solutionDesignDropdownBtn = document.getElementById('solutionDesignDropdownBtn');
            const solutionDesignMenu = document.getElementById('solutionDesignMenu');
            const executionDropdownBtn = document.getElementById('executionDropdownBtn');
            const executionMenu = document.getElementById('executionMenu');
            // NEW PROMPT ELEMENTS
            const myPromptsDropdownBtn = document.getElementById('myPromptsDropdownBtn'); // NEW
            const myPromptsMenu = document.getElementById('myPromptsMenu'); // NEW
            let MIN_HEIGHT = 0; // Calculated minimum height (1 line)

                        // ===== PHASE 1 FEATURE: PERSISTENT MEMORY SYSTEM =====
            
            // User Profile Storage
            const USER_PROFILE_KEY = 'bobUserProfile';
            
            // Initialize or load user profile
            let userProfile = JSON.parse(localStorage.getItem(USER_PROFILE_KEY)) || {
                industry: '',
                consultingAreas: [],
                previousTopics: [],
                conversationSummaries: [],
                preferences: {
                    preferredAnalysisTypes: [],
                    favoritePrompts: []
                },
                lastVisit: null,
                totalInteractions: 0,
                createdAt: new Date().toISOString()
            };
            
            // Save user profile to localStorage
            function saveUserProfile() {
                userProfile.lastVisit = new Date().toISOString();
                localStorage.setItem(USER_PROFILE_KEY, JSON.stringify(userProfile));
            }
            
            // Extract topics from conversation
            function extractTopicsFromConversation() {
                const topics = [];
                chatHistory.forEach(entry => {
                    if (entry.role === 'user') {
                        const text = entry.parts[0].text.toLowerCase();
                        // Simple keyword extraction
                        if (text.includes('market')) topics.push('market analysis');
                        if (text.includes('swot')) topics.push('SWOT analysis');
                        if (text.includes('competitor')) topics.push('competitor analysis');
                        if (text.includes('financial')) topics.push('financial analysis');
                        if (text.includes('strategy')) topics.push('strategy');
                    }
                });
                return [...new Set(topics)]; // Remove duplicates
            }
            
            // Add conversation summary to profile
            function saveConversationSummary() {
                if (chatHistory.length > 1) {
                    const topics = extractTopicsFromConversation();
                    const summary = {
                        date: new Date().toISOString(),
                        topics: topics,
                        messageCount: chatHistory.length - 1,
                        id: Date.now()
                    };
                    
                    userProfile.conversationSummaries.push(summary);
                    userProfile.previousTopics = [
                        ...new Set([...userProfile.previousTopics, ...topics])
                    ].slice(0, 20); // Keep last 20 unique topics
                    
                    userProfile.totalInteractions++;
                    saveUserProfile();
                }
            }

                        // ===== PHASE 1 FEATURE: PROACTIVE CHECK-INS =====
            
            // Check if returning user and show personalized welcome
            function checkForProactiveWelcome() {
                const lastVisit = userProfile.lastVisit ? new Date(userProfile.lastVisit) : null;
                const now = new Date();
                
                if (lastVisit) {
                    const hoursSinceLastVisit = (now - lastVisit) / (1000 * 60 * 60);
                    
                    // If more than 24 hours since last visit
                    if (hoursSinceLastVisit > 24 && userProfile.previousTopics.length > 0) {
                        setTimeout(() => {
                            const daysSince = Math.floor(hoursSinceLastVisit / 24);
                            const topicsText = userProfile.previousTopics.slice(0, 3).join(', ');
                            
                            const welcomeBackMessage = `Welcome back! It's been ${daysSince} day${daysSince > 1 ? 's' : ''} since your last visit. 

I see we previously discussed: **${topicsText}**. 

Would you like to:
â€¢ Continue where we left off?
â€¢ Get updates on these topics?
â€¢ Start a new analysis?

How can I assist you today?`;
                            
                            createMessageBubble(welcomeBackMessage, 'model');
                        }, 1500); // Show after 1.5 seconds
                    } else if (hoursSinceLastVisit > 1 && userProfile.totalInteractions > 3) {
                        // Short absence but active user
                        setTimeout(() => {
                            const recentTopics = userProfile.previousTopics.slice(0, 2).join(' and ');
                            const quickWelcome = `Welcome back! Ready to continue with ${recentTopics || 'your consulting questions'}?`;
                            
                            createMessageBubble(quickWelcome, 'model');
                        }, 1000);
                    }
                }
                
                // Update last visit
                userProfile.lastVisit = now.toISOString();
                saveUserProfile();
            }
            
            // Call proactive welcome on page load
            setTimeout(() => {
                checkForProactiveWelcome();
            }, 500); // Wait 500ms after page loads

                        
            // ===== PHASE 1 FEATURE: MULTI-STEP TASK TEMPLATES =====
            
            // Define multi-step workflows
            const WORKFLOWS = {
                'market-entry-strategy': {
                    name: 'Complete Market Entry Strategy',
                    steps: [
                        'Industry Trends Snapshot',
                        'Competitor Benchmarking',
                        'SWOT Analysis',
                        'Market Entry Strategy Framework'
                    ],
                    description: 'Full market entry analysis with trends, competitors, SWOT, and strategy'
                },
                'business-health-check': {
                    name: 'Business Health Check',
                    steps: [
                        'SWOT Analysis',
                        'Financial Health Snapshot',
                        'Operational Efficiency Review'
                    ],
                    description: 'Comprehensive business health assessment'
                },
                'competitive-analysis': {
                    name: 'Competitive Analysis Package',
                    steps: [
                        'Competitor Benchmarking',
                        'Market Positioning Map',
                        'Competitive Advantage Analysis'
                    ],
                    description: 'Deep dive into competitive landscape'
                }
            };
                        
            // ===== PHASE 2 FEATURE: TOOL ORCHESTRATION FRAMEWORK =====
            
            // Available tools Bob can use
            const BOB_TOOLS = {
                googleSearch: {
                    enabled: true,
                    name: 'Google Search',
                    description: 'Search the web for current information',
                    icon: 'ðŸ”'
                },
                dataAnalysis: {
                    enabled: true,
                    name: 'Data Analysis',
                    description: 'Perform calculations and analyze data',
                    icon: 'ðŸ“Š'
                },
                documentExport: {
                    enabled: true,
                    name: 'Document Export',
                    description: 'Export conversation or analysis as text file',
                    icon: 'ðŸ“„'
                },
                chartGeneration: {
                    enabled: true,
                    name: 'Chart Generation',
                    description: 'Create visual charts and graphs',
                    icon: 'ðŸ“ˆ'
                }
            };
            
            // Tool usage tracking
            let toolUsageHistory = [];
            
            // Determine which tools are needed for a query
            function determineRequiredTools(userQuery) {
                const query = userQuery.toLowerCase();
                const tools = [];
                
                // Check for search needs
                if (query.includes('latest') || query.includes('current') || 
                    query.includes('recent') || query.includes('trend')) {
                    tools.push('googleSearch');
                }
                
                // Check for data analysis needs
                if (query.includes('calculate') || query.includes('analyze data') || 
                    query.includes('numbers') || query.includes('statistics')) {
                    tools.push('dataAnalysis');
                }
                
                // Check for export needs
                if (query.includes('export') || query.includes('download') || 
                    query.includes('save as file')) {
                    tools.push('documentExport');
                }
                
                // Check for visualization needs
                if (query.includes('chart') || query.includes('graph') || 
                    query.includes('visualize') || query.includes('plot')) {
                    tools.push('chartGeneration');
                }
                
                return tools;
            }
            
            // Execute document export tool
            function executeDocumentExport() {
                let exportText = 'BOB CONSULTING SESSION EXPORT\n';
                exportText += '='.repeat(50) + '\n';
                exportText += `Date: ${new Date().toLocaleString()}\n`;
                exportText += `Total Messages: ${chatHistory.length - 1}\n`;
                exportText += '='.repeat(50) + '\n\n';
                
                chatHistory.forEach((entry, index) => {
                    if (index > 0) {
                        const role = entry.role === 'user' ? 'YOU' : 'BOB';
                        const text = entry.parts[0].text;
                        exportText += `[${role}]\n${text}\n\n`;
                        exportText += '-'.repeat(50) + '\n\n';
                    }
                });
                
                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bob-session-${Date.now()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Track tool usage
                toolUsageHistory.push({
                    tool: 'documentExport',
                    timestamp: new Date().toISOString()
                });
                
                return 'Document exported successfully!';
            }
            
            // Execute data analysis tool (simple implementation)
            function executeDataAnalysis(data) {
                // This is a simplified version - can be expanded
                try {
                    const numbers = data.match(/\d+(\.\d+)?/g)?.map(Number) || [];
                    
                    if (numbers.length === 0) {
                        return 'No numerical data found to analyse.';
                    }
                    
                    const sum = numbers.reduce((a, b) => a + b, 0);
                    const avg = sum / numbers.length;
                    const max = Math.max(...numbers);
                    const min = Math.min(...numbers);
                    
                    toolUsageHistory.push({
                        tool: 'dataAnalysis',
                        timestamp: new Date().toISOString()
                    });
                    
                    return `Data Analysis Results:
- Count: ${numbers.length} values
- Sum: ${sum.toFixed(2)}
- Average: ${avg.toFixed(2)}
- Maximum: ${max}
- Minimum: ${min}`;
                } catch (error) {
                    return 'Error analyzing data.';
                }
            }

            // Execute multi-step workflow
            async function executeWorkflow(workflowKey, context = '') {
                const workflow = WORKFLOWS[workflowKey];
                if (!workflow) {
                    alert('Workflow not found');
                    return;
                }
                
                // Show workflow initiation message
                const initiationMessage = `Starting **${workflow.name}** workflow...

This will execute ${workflow.steps.length} analysis steps:
${workflow.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

${context ? `\nContext: ${context}` : ''}`;
                
                createMessageBubble(initiationMessage, 'model');
                
                // Execute each step
                for (let i = 0; i < workflow.steps.length; i++) {
                    const step = workflow.steps[i];
                    
                    // Add user message for this step
                    const stepMessage = `[Workflow Step ${i + 1}/${workflow.steps.length}] ${step}${context ? ': ' + context : ''}`;
                    createMessageBubble(stepMessage, 'user');
                    
                    chatHistory.push({
                        role: "user",
                        parts: [{ text: stepMessage }]
                    });
                    
                    // Execute the prompt using sendMessage logic
                    await executePromptStep(PROMPT_MAP[step], context);
                    
                    // Small delay between steps
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Completion message
                const completionMessage = `âœ… **${workflow.name}** complete! 

I've generated ${workflow.steps.length} comprehensive analyses. Review the insights above and let me know if you'd like to:
â€¢ Deep dive into any specific area
â€¢ Generate takeaways
â€¢ Start another workflow`;
                
                createMessageBubble(completionMessage, 'model');
                
                // Save this workflow execution to user profile
                userProfile.preferences.preferredAnalysisTypes.push(workflowKey);
                saveUserProfile();
            }
            
            // Execute individual prompt step (reuses existing API call logic)
            async function executePromptStep(promptTemplate, userContext) {
                const apiKey = apiKeyInput.value.trim();
                
                // Show "Thinking..." indicator
                const loadingBubble = document.createElement('div');
                loadingBubble.classList.add('flex', 'justify-start');
                loadingBubble.innerHTML = `
                    <div class="bg-gray-700 text-gray-300 rounded-xl rounded-bl-none p-3 max-w-sm shadow-md">
                        <div class="flex items-center">
                            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Thinking...
                        </div>
                    </div>
                `;
                chatArea.appendChild(loadingBubble);
                chatArea.scrollTop = chatArea.scrollHeight;
                
                try {
                    const finalPrompt = promptTemplate.replace(/\[input[^\]]*\]/gi, userContext || '[No specific context provided]');
                    
                    chatHistory.push({
                        role: "user",
                        parts: [{ text: finalPrompt }]
                    });
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        systemInstruction: {
                            parts: [{ text: `You are a professional business consultant named Bob. Your role is to provide clear, actionable, and well-structured responses to business-related queries. Use Markdown formatting.` }]
                        },
                        contents: chatHistory,
                        tools: [{ "google_search": {} }],
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const aiText = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't process that request.";
                    
                    chatArea.removeChild(loadingBubble);
                    
                    chatHistory.push({
                        role: "model",
                        parts: [{ text: aiText }]
                    });
                    
                    createMessageBubble(aiText, 'model');
                    
                } catch (error) {
                    if (chatArea.contains(loadingBubble)) {
                        chatArea.removeChild(loadingBubble);
                    }
                    console.error('Error in workflow step:', error);
                    createMessageBubble('Error processing this step. Moving to next...', 'model');
                }
            }

                        
            // ===== PHASE 2 FEATURE: GOAL-BASED REASONING =====
            
            // Decompose complex goals into sub-goals
            function decomposeGoal(goalStatement) {
                const goal = goalStatement.toLowerCase();
                const subGoals = [];
    
                // Pattern matching for common business goals
                if (goal.includes('launch') || goal.includes('start') || goal.includes('new business') || goal.includes('open')) {
                    subGoals.push(
                        { task: 'Industry Trends Snapshot', priority: 'high' },
                        { task: 'Market Analysis', priority: 'high' },
                        { task: 'Competitor Benchmarking', priority: 'high' },
                        { task: 'Business Plan Outline', priority: 'medium' },
                        { task: 'Go-to-market Strategy', priority: 'medium' }
                    );
                } else if (goal.includes('expand') || goal.includes('growth') || goal.includes('scale') || goal.includes('grow')) {
                    subGoals.push(
                        { task: 'Market Analysis', priority: 'high' },
                        { task: 'SWOT Analysis', priority: 'high' },
                        { task: 'Ansoff Matrix', priority: 'high' },
                        { task: 'Market Entry Strategy', priority: 'medium' },
                        { task: 'Implementation Plan Outline', priority: 'medium' }
                    );
                } else if (goal.includes('improve') || goal.includes('optimize') || goal.includes('enhance')) {
                    subGoals.push(
                        { task: 'SWOT Analysis', priority: 'high' },
                        { task: '5 Forces Analysis', priority: 'high' },
                        { task: 'Risk Analysis', priority: 'medium' },
                        { task: 'KPI Dashboard Mockup', priority: 'medium' },
                        { task: 'Implementation Plan Outline', priority: 'medium' }
                    );
                } else {
                    // Generic goal breakdown
                    subGoals.push(
                        { task: 'SWOT Analysis', priority: 'high' },
                        { task: 'Market Analysis', priority: 'high' },
                        { task: 'Risk Analysis', priority: 'medium' },
                        { task: 'Implementation Plan Outline', priority: 'medium' }
                    );
                }
    
                return subGoals;
            }

            
            // Create execution plan from sub-goals
            function createExecutionPlan(subGoals) {
                const plan = {
                    highPriority: subGoals.filter(g => g.priority === 'high'),
                    mediumPriority: subGoals.filter(g => g.priority === 'medium'),
                    steps: subGoals.map((g, i) => ({
                        step: i + 1,
                        task: g.task,
                        priority: g.priority,
                        status: 'pending'
                    }))
                };
                
                return plan;
            }

            
// Track if we're waiting for execution plan response
let awaitingPlanResponse = false;

// Execute goal plan automatically
async function executeGoalPlanAutomatically(goal, plan) {
    createMessageBubble(`ðŸš€ Starting automatic execution of your goal plan...`, 'model');
    
    for (let i = 0; i < plan.steps.length; i++) {
        const step = plan.steps[i];
        
        // Show which step is being executed
        createMessageBubble(`\n**Step ${i + 1}/${plan.steps.length}: ${step.task}**\n*Priority: ${step.priority}*`, 'model');
        
        // Small delay between steps
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Find matching prompt in PROMPT_MAP
        const promptKey = step.task;
        if (PROMPT_MAP[promptKey]) {
            await executePromptStep(PROMPT_MAP[promptKey], goal);
        } else {
            createMessageBubble(`âš ï¸ Prompt template not found for "${step.task}". Skipping...`, 'model');
        }
        
        // Delay before next step
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    
    createMessageBubble(`\nâœ… **Goal Plan Complete!**\n\nI've executed all ${plan.steps.length} steps for your goal: "${goal}"\n\nReview the analyses above and let me know if you'd like to:\nâ€¢ Deep dive into any specific area\nâ€¢ Generate takeaways\nâ€¢ Start a new goal`, 'model');
    
    // Reset flag
    awaitingPlanResponse = false;
}
            
            // Process and execute a complex goal
            async function processGoal(userGoal) {
                // Show goal analysis message
                const analysisMessage = `ðŸŽ¯ **Goal Analysis**

I'm breaking down your goal: "${userGoal}"

Let me identify the key steps needed...`;
                
                createMessageBubble(analysisMessage, 'model');
                
                // Small delay for effect
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Decompose the goal
                const subGoals = decomposeGoal(userGoal);
                const plan = createExecutionPlan(subGoals);
                
                // Show the execution plan
                const planMessage = `ðŸ“‹ **Execution Plan**

I've identified ${plan.steps.length} key steps to achieve your goal:

**High Priority:**
${plan.highPriority.map((g, i) => `${i + 1}. ${g.task}`).join('\n')}

**Medium Priority:**
${plan.mediumPriority.map((g, i) => `${i + 1}. ${g.task}`).join('\n')}

Would you like me to:
1. Execute this plan automatically (runs all steps)
2. Walk through it step-by-step with you
3. Modify the plan first

Reply with 1, 2, or 3.`;
                
                createMessageBubble(planMessage, 'model');
                
                // Store the plan for potential execution
                window.currentGoalPlan = plan;
                window.currentGoal = userGoal;

                // Set flag to intercept next user message
                awaitingPlanResponse = true;

                return plan;

            }

                        
            // ===== PHASE 2 FEATURE: CONTEXT-AWARE SUGGESTIONS =====
            
            // Analyze conversation patterns
            function identifyConversationPatterns(history) {
                const patterns = [];
                const recentMessages = history.slice(-6); // Last 6 messages
                
                // Pattern: Multiple questions about same topic
                const topics = {};
                recentMessages.forEach(msg => {
                    if (msg.role === 'user') {
                        const text = msg.parts[0].text.toLowerCase();
                        if (text.includes('market')) topics.market = (topics.market || 0) + 1;
                        if (text.includes('financial')) topics.financial = (topics.financial || 0) + 1;
                        if (text.includes('competitor')) topics.competitor = (topics.competitor || 0) + 1;
                        if (text.includes('strategy')) topics.strategy = (topics.strategy || 0) + 1;
                    }
                });
                
                Object.keys(topics).forEach(topic => {
                    if (topics[topic] >= 2) {
                        patterns.push(`deep-dive-${topic}`);
                    }
                });
                
                // Pattern: Incomplete analysis (SWOT without implementation)
                const hasSWOT = history.some(msg => 
                    msg.parts[0].text.toLowerCase().includes('swot')
                );
                const hasImplementation = history.some(msg => 
                    msg.parts[0].text.toLowerCase().includes('implementation') ||
                    msg.parts[0].text.toLowerCase().includes('action plan')
                );
                
                if (hasSWOT && !hasImplementation) {
                    patterns.push('swot-without-implementation');
                }
                
                // Pattern: Analysis without next steps
                const hasAnalysis = history.some(msg =>
                    msg.parts[0].text.toLowerCase().includes('analysis') ||
                    msg.parts[0].text.toLowerCase().includes('trends')
                );
                const hasNextSteps = history.some(msg =>
                    msg.parts[0].text.toLowerCase().includes('next step') ||
                    msg.parts[0].text.toLowerCase().includes('action')
                );
                
                if (hasAnalysis && !hasNextSteps && history.length > 4) {
                    patterns.push('analysis-without-action');
                }
                
                return patterns;
            }
            
            // Generate proactive suggestions based on patterns
            function generateProactiveSuggestions(patterns) {
                const suggestions = [];
                
                patterns.forEach(pattern => {
                    if (pattern === 'swot-without-implementation') {
                        suggestions.push({
                            message: "I notice we completed a SWOT analysis. Would you like me to create an implementation roadmap based on those insights?",
                            action: 'create-implementation-plan'
                        });
                    }
                    
                    if (pattern === 'analysis-without-action') {
                        suggestions.push({
                            message: "We've done some great analysis! Would you like me to convert these insights into concrete action items?",
                            action: 'generate-action-items'
                        });
                    }
                    
                    if (pattern.startsWith('deep-dive-')) {
                        const topic = pattern.replace('deep-dive-', '');
                        suggestions.push({
                            message: `You seem very interested in ${topic} analysis. Would you like me to run a comprehensive ${topic} workflow?`,
                            action: `workflow-${topic}`
                        });
                    }
                });
                
                return suggestions;
            }
            
            // Check and show proactive suggestions periodically
            let suggestionCheckInterval = null;
            
            function startContextAwareSuggestions() {
                // Check every 30 seconds if there are relevant suggestions
                suggestionCheckInterval = setInterval(() => {
                    if (chatHistory.length > 4) {
                        const patterns = identifyConversationPatterns(chatHistory);
                        
                        if (patterns.length > 0) {
                            const suggestions = generateProactiveSuggestions(patterns);
                            
                            if (suggestions.length > 0 && Math.random() > 0.7) { // 30% chance to show
                                const suggestion = suggestions[0]; // Show first suggestion
                                
                                const proactiveMessage = `ðŸ’¡ **Proactive Suggestion**

${suggestion.message}`;
                                
                                createMessageBubble(proactiveMessage, 'model');
                                
                                // Stop checking for a while after showing suggestion
                                clearInterval(suggestionCheckInterval);
                                setTimeout(() => {
                                    startContextAwareSuggestions();
                                }, 120000); // Resume after 2 minutes
                            }
                        }
                    }
                }, 30000); // Check every 30 seconds
            }
            
            // Start context-aware suggestions on page load
            setTimeout(() => {
                startContextAwareSuggestions();
                        }, 60000); // Start checking after 1 minute of use
            
            // ===== PHASE 3 FEATURE: AUTONOMOUS RESEARCH AGENT =====
            
            let activeResearchSession = null;
            
            const RESEARCH_FRAMEWORK = {
                phases: ['Discovery', 'Deep Dive', 'Synthesis', 'Validation'],
                maxQueries: 5,
                timeout: 180000
            };
            
            async function startAutonomousResearch(topic, depth = 'standard') {
                const sessionId = Date.now();
                activeResearchSession = {
                    id: sessionId,
                    topic: topic,
                    depth: depth,
                    findings: [],
                    phase: 0,
                    startTime: new Date()
                };
                
                createMessageBubble(`ðŸ”¬ **Autonomous Research Initiated**

Topic: "${topic}"
Depth: ${depth}

I'll conduct comprehensive research across multiple phases:
1. **Discovery** - Identifying key aspects
2. **Deep Dive** - Gathering detailed information
3. **Synthesis** - Connecting insights
4. **Validation** - Cross-referencing findings

Starting research...`, 'assistant');
                
                await executeResearchPhase('Discovery', topic);
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                await executeResearchPhase('Deep Dive', topic);
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                await executeResearchPhase('Synthesis', topic);
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                await executeResearchPhase('Validation', topic);
                
                await generateResearchReport(topic);
                
                activeResearchSession = null;
            }
            
            async function executeResearchPhase(phase, topic) {
                createMessageBubble(`ðŸ“Š **Phase: ${phase}**

Analyzing ${topic}...`, 'assistant');
                
                let phasePrompt = '';
                
                switch(phase) {
                    case 'Discovery':
                        phasePrompt = `Analyze "${topic}" and provide EXACTLY 5 key aspects in this format:

                1. [Aspect Name]: [One sentence description]
                2. [Aspect Name]: [One sentence description]
                3. [Aspect Name]: [One sentence description]
                4. [Aspect Name]: [One sentence description]
                5. [Aspect Name]: [One sentence description]

                Keep each point to ONE sentence maximum. Be concise and specific.`;
                        break;
        
                    case 'Deep Dive':
                        phasePrompt = `Analyze "${topic}" in this EXACT format:

                **Current Trends:**
                â€¢ [Trend 1]
                â€¢ [Trend 2]
                â€¢ [Trend 3]

                **Key Players:**
                â€¢ [Player 1 and their role]
                â€¢ [Player 2 and their role]

                **Main Challenges:**
                â€¢ [Challenge 1]
                â€¢ [Challenge 2]

                **Key Opportunities:**
                â€¢ [Opportunity 1]
                â€¢ [Opportunity 2]

                Use bullet points. Keep each point to 1-2 sentences maximum.`;
                        break;
        
                    case 'Synthesis':
                        phasePrompt = `Synthesize insights about "${topic}" in this EXACT format:

                **Key Patterns Identified:**
                â€¢ [Pattern 1]
                â€¢ [Pattern 2]

                **Strategic Connections:**
                 â€¢ [Connection 1]
                 â€¢ [Connection 2]

                **Business Implications:**
                â€¢ [Implication 1]
                â€¢ [Implication 2]

                Keep each point concise (1-2 sentences).`;
                        break;
        
                    case 'Validation':
                        phasePrompt = `Validate findings about "${topic}" in this EXACT format:

                **Validated Key Findings:**
                â€¢ [Finding 1]
                â€¢ [Finding 2]
                â€¢ [Finding 3]

                **Areas Requiring Further Investigation:**
                â€¢ [Area 1]
                â€¢ [Area 2]

                **Confidence Level:** [High/Medium/Low]

                Keep each point to 1-2 sentences.`;
                        break;
                }

                
                try {
                    const apiKey = apiKeyInput.value.trim();
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        systemInstruction: {
                            parts: [{ text: `You are Bob, an autonomous research consultant conducting independent research. Provide thorough, well-researched insights.` }]
                        },
                        contents: [{
                            role: "user",
                            parts: [{ text: phasePrompt }]
                        }],
                        tools: [{ "google_search": {} }]
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const findings = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Research phase incomplete.";
                    
                    activeResearchSession.findings.push({
                        phase: phase,
                        content: findings
                    });
                    
                    createMessageBubble(`âœ… ${phase} complete`, 'assistant');
                    
                } catch (error) {
                    console.error(`Research phase ${phase} error:`, error);
                    createMessageBubble(`âš ï¸ ${phase} encountered issues, continuing...`, 'assistant');
                }
            }
            
            async function generateResearchReport(topic) {
                const findings = activeResearchSession.findings
                    .map(f => `## ${f.phase} Phase\n\n${f.content}`)
                    .join('\n\n---\n\n');
    
                createMessageBubble(`# ðŸ“‘ Comprehensive Research Report: ${topic}

            ${findings}

            ---

            ## ðŸ“Š Research Summary

            - **Total Phases Completed:** ${activeResearchSession.findings.length}
            - **Research Duration:** ${Math.round((new Date() - activeResearchSession.startTime) / 1000)} seconds
            - **Findings Synthesized:** ${activeResearchSession.findings.length} comprehensive phases

            ## ðŸŽ¯ Recommended Next Steps

            â€¢ **Deep Dive:** Ask me to elaborate on any specific finding
            â€¢ **Action Plan:** Request actionable recommendations  
            â€¢ **Implementation:** Start implementation planning
            â€¢ **Export:** Use "Export Chat" to save this research report`, 'assistant');

                
                userProfile.conversationSummaries.push({
                    date: new Date().toISOString(),
                    type: 'research',
                    topic: topic,
                    findings: activeResearchSession.findings.length
                });
                saveUserProfile();
            }
            
            function isResearchRequest(message) {
                const researchKeywords = [
                    'research', 'investigate', 'study', 'analyze deeply',
                    'comprehensive analysis', 'deep dive', 'explore',
                    'find information about', 'gather data on'
                ];
                
                const lowerMessage = message.toLowerCase();
                return researchKeywords.some(keyword => lowerMessage.includes(keyword));
            }
            
            // ===== PHASE 3 FEATURE: LEARNING & ADAPTATION SYSTEM =====
            
            const LEARNING_DB_KEY = 'bobLearningDatabase';
            
            let learningDB = JSON.parse(localStorage.getItem(LEARNING_DB_KEY)) || {
                successfulPrompts: [],
                userPreferences: {},
                performanceMetrics: {
                    totalInteractions: 0,
                    successfulWorkflows: 0,
                    averageSessionLength: 0
                },
                adaptations: [],
                lastUpdated: new Date().toISOString()
            };
            
            function saveLearningDB() {
                learningDB.lastUpdated = new Date().toISOString();
                localStorage.setItem(LEARNING_DB_KEY, JSON.stringify(learningDB));
            }
            
            function recordSuccessfulInteraction(type, details) {
                learningDB.successfulPrompts.push({
                    type: type,
                    details: details,
                    timestamp: new Date().toISOString(),
                    context: chatHistory.slice(-3)
                });
                
                if (learningDB.successfulPrompts.length > 50) {
                    learningDB.successfulPrompts = learningDB.successfulPrompts.slice(-50);
                }
                
                learningDB.performanceMetrics.totalInteractions++;
                saveLearningDB();
            }
            
            function learnFromInteraction(userMessage, bobResponse) {
                const messageLength = userMessage.length;
                if (!learningDB.userPreferences.preferredMessageLength) {
                    learningDB.userPreferences.preferredMessageLength = [];
                }
                learningDB.userPreferences.preferredMessageLength.push(messageLength);
                
                if (learningDB.userPreferences.preferredMessageLength.length > 20) {
                    learningDB.userPreferences.preferredMessageLength.shift();
                }
                
                const analysisTypes = ['SWOT', 'Market', 'Competitor', 'Financial', 'Risk'];
                analysisTypes.forEach(type => {
                    if (userMessage.toLowerCase().includes(type.toLowerCase())) {
                        if (!learningDB.userPreferences.preferredAnalyses) {
                            learningDB.userPreferences.preferredAnalyses = {};
                        }
                        learningDB.userPreferences.preferredAnalyses[type] = 
                            (learningDB.userPreferences.preferredAnalyses[type] || 0) + 1;
                    }
                });
                
                saveLearningDB();
            }
            
            function generateAdaptiveRecommendations() {
                const recommendations = [];
                
                if (learningDB.userPreferences.preferredAnalyses) {
                    const topAnalysis = Object.entries(learningDB.userPreferences.preferredAnalyses)
                        .sort((a, b) => b[1] - a[1])[0];
                    
                    if (topAnalysis && topAnalysis[1] > 3) {
                        recommendations.push(`You frequently use ${topAnalysis[0]} analysis. Would you like me to create a custom workflow combining ${topAnalysis[0]} with related analyses?`);
                    }
                }
                
                if (learningDB.performanceMetrics.successfulWorkflows > 5) {
                    recommendations.push(`I've noticed you've completed ${learningDB.performanceMetrics.successfulWorkflows} workflows successfully. I'm learning your preferred approach and can suggest optimized workflows.`);
                }
                
                return recommendations;
            }
            
            function showLearningInsights() {
                const avgMsgLength = learningDB.userPreferences.preferredMessageLength?.length > 0
                ? Math.round(learningDB.userPreferences.preferredMessageLength.reduce((a, b) => a + b, 0) / learningDB.userPreferences.preferredMessageLength.length)
                : 0;
    
                const topAnalyses = learningDB.userPreferences.preferredAnalyses
                    ? Object.entries(learningDB.userPreferences.preferredAnalyses)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([type, count]) => `â€¢ **${type} Analysis:** ${count} times`)
                        .join('\n')
                    : 'â€¢ No analysis patterns detected yet';
    
                const recommendations = generateAdaptiveRecommendations();
                const adaptiveSection = recommendations.length > 0 
                    ? recommendations.map((r, i) => `${i + 1}. ${r}`).join('\n\n')
                    : 'ðŸŒ± Keep using me to unlock personalized recommendations!\n\nI need more interactions to identify your patterns and preferences.';
    
                const insights = `# ðŸ§  Learning & Adaptation Insights

            ## ðŸ“Š Your Interaction Patterns

            - **Total Interactions:** ${learningDB.performanceMetrics.totalInteractions} conversations
            - **Successful Workflows:** ${learningDB.performanceMetrics.successfulWorkflows} completed
            - **Average Message Length:** ${avgMsgLength} characters
            - **Session Duration:** Tracking across multiple sessions

            ## ðŸŽ¯ Most Frequently Used Analyses

            ${topAnalyses}

            ## ðŸ’¡ Adaptive Recommendations

            ${adaptiveSection}

            ## ðŸ”„ Learning Status

            âœ… **Active Learning:** I'm continuously adapting to your consulting style and preferences
            âœ… **Pattern Recognition:** Analyzing your communication patterns and analysis preferences  
            âœ… **Recommendation Engine:** Building personalized suggestions based on your usage

            ---

            *ðŸ’¡ The more you interact with me, the better I become at anticipating your needs and providing tailored recommendations!*`;
    
                createMessageBubble(insights, 'assistant');
            }

            
            // ===== PHASE 3 FEATURE: MULTI-AGENT COLLABORATION =====
            
            const EXPERT_AGENTS = {
                strategist: {
                    name: 'Strategy Expert',
                    icon: 'ðŸŽ¯',
                    expertise: 'Long-term planning, competitive positioning, growth strategies',
                    systemPrompt: 'You are a senior strategy consultant specializing in long-term business planning and competitive positioning.'
                },
                financial: {
                    name: 'Financial Analyst',
                    icon: 'ðŸ’°',
                    expertise: 'Financial modeling, ROI analysis, cost optimization',
                    systemPrompt: 'You are a financial analyst expert in business economics, financial modeling, and investment analysis.'
                },
                operations: {
                    name: 'Operations Specialist',
                    icon: 'âš™ï¸',
                    expertise: 'Process optimization, efficiency, implementation',
                    systemPrompt: 'You are an operations management specialist focused on efficiency, process optimization, and execution.'
                },
                marketing: {
                    name: 'Marketing Strategist',
                    icon: 'ðŸ“¢',
                    expertise: 'Brand positioning, customer acquisition, market penetration',
                    systemPrompt: 'You are a marketing strategy expert specializing in brand building, customer acquisition, and market expansion.'
                }
            };
            
            async function executeMultiAgentCollaboration(topic, agents = ['strategist', 'financial', 'operations']) {
                createMessageBubble(`ðŸ‘¥ **Multi-Agent Collaboration Initiated**

Topic: "${topic}"

Consulting with ${agents.length} expert agents:
${agents.map(id => `${EXPERT_AGENTS[id].icon} ${EXPERT_AGENTS[id].name}`).join('\n')}

Each expert will provide their specialized perspective...`, 'assistant');
                
                const expertInsights = [];
                
                for (let i = 0; i < agents.length; i++) {
                    const agentId = agents[i];
                    const agent = EXPERT_AGENTS[agentId];
                    
                    createMessageBubble(`${agent.icon} **Consulting ${agent.name}...**`, 'assistant');
                    
                    const insight = await getAgentPerspective(agent, topic);
                    expertInsights.push({
                        agent: agent,
                        insight: insight
                    });
                    
                    createMessageBubble(`## ${agent.icon} ${agent.name}'s Analysis

                    **Expertise:** ${agent.expertise}

                    ${insight}

                    ---`, 'assistant');

                    
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                
                await synthesizeAgentInsights(topic, expertInsights);
            }
            
            async function getAgentPerspective(agent, topic) {
                try {
                    const apiKey = apiKeyInput.value.trim();
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        systemInstruction: {
                            parts: [{ text: agent.systemPrompt }]
                        },
                        contents: [{
                            role: "user",
                            parts: [{ text: `As a ${agent.name}, analyze "${topic}" in this EXACT format:

                            **Key Recommendations:**
                            1. [Specific recommendation related to ${agent.expertise}]
                            2. [Specific recommendation related to ${agent.expertise}]
                            3. [Specific recommendation related to ${agent.expertise}]
                            
                            **Critical Considerations:**
                            â€¢ [Important factor 1]
                            â€¢ [Important factor 2]
                            
                            **Expected Impact:** [One sentence about potential outcomes]
                            
                            Keep ALL points to 1-2 sentences maximum. Be specific and actionable.` }]

                        }],
                        tools: [{ "google_search": {} }]
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    return result?.candidates?.[0]?.content?.parts?.[0]?.text || "Perspective unavailable.";
                    
                } catch (error) {
                    console.error(`Agent ${agent.name} error:`, error);
                    return `${agent.name} perspective temporarily unavailable.`;
                }
            }
            
            async function synthesizeAgentInsights(topic, expertInsights) {
                createMessageBubble(`ðŸ”„ **Synthesizing Expert Perspectives...**`, 'assistant');
                
                const synthesisPrompt = `Based on these expert perspectives about "${topic}":

                ${expertInsights.map(ei => `**${ei.agent.name}:**\n${ei.insight}`).join('\n\n')}
                
                Synthesize in this EXACT format:
                
                **Consensus Points:**
                â€¢ [What all experts agree on - point 1]
                â€¢ [What all experts agree on - point 2]
                
                **Complementary Insights:**
                â€¢ [How perspectives strengthen each other - point 1]
                â€¢ [How perspectives strengthen each other - point 2]
                
                **Priority Actions:**
                1. [Immediate action item]
                2. [Short-term action item]
                3. [Long-term strategic action]
                
                **Success Metrics:**
                â€¢ [How to measure success - metric 1]
                â€¢ [How to measure success - metric 2]
                
                Keep ALL points to 1-2 sentences maximum. Be specific and actionable.`;
                
                try {
                    const apiKey = apiKeyInput.value.trim();
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        systemInstruction: {
                            parts: [{ text: 'You are Bob, synthesizing insights from multiple expert consultants into cohesive recommendations.' }]
                        },
                        contents: [{
                            role: "user",
                            parts: [{ text: synthesisPrompt }]
                        }]
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const synthesis = result?.candidates?.[0]?.content?.parts?.[0]?.text || "Synthesis incomplete.";
                    
                    createMessageBubble(`# ðŸŽ¯ Integrated Expert Analysis

                    ${synthesis}

                    ---

                    ## âœ… Multi-Agent Collaboration Summary

                    - **Expert Consultants:** ${expertInsights.length} specialists consulted
                    - **Perspectives Analyzed:** Strategy, Financial, and Operations viewpoints
                    - **Synthesis Status:** Complete - All insights integrated into unified recommendations
                    - **Ready for:** Strategic planning and implementation

                    **ðŸ’¡ Tip:** Export this analysis for your strategic planning sessions!`, 'assistant');

                    
                } catch (error) {
                    console.error('Synthesis error:', error);
                    createMessageBubble('âš ï¸ Synthesis encountered issues.', 'assistant');
                }
            }
            
            function isMultiAgentRequest(message) {
                const keywords = [
                    'expert panel', 'multiple perspectives', 'different experts',
                    'consult experts', 'expert opinions', 'panel discussion',
                    'multi-agent', 'collaborate', 'expert team'
                ];
                
                const lowerMessage = message.toLowerCase();
                return keywords.some(keyword => lowerMessage.includes(keyword));
            }
            
            // --- PROMPT DEFINITIONS ---

            const PROMPT_MAP = {
                // Initial Setup (Phase I)
                'Industry Trends Snapshot': `Generate a **rapid, high-level Industry Trends Snapshot** for [input SPECIFIED INDUSTRY]. 

The output MUST strictly follow this high-readability structure:

# [Industry] Trends Snapshot
[concise, clear introductory explanation]

## Key Trend 1: [Trend Name]
* [concise, clear bullet point 1]
* [concise, clear bullet point 2]
* [concise, clear bullet point 3]

## Key Trend 2: [Trend Name]
* [concise, clear bullet point 1]
* [concise, clear bullet point 2]
* [concise, clear bullet point 3]
... (3 to 5 trends total)

## Summary Table
| Trend | Primary Impact |
|---|---|
| [Trend 1 Name] | * [Impact bullet 1] <br> * [Impact bullet 2] |
| [Trend 2 Name] | * [Impact bullet 1] <br> * [Impact bullet 2] |
| [Trend 3 Name] | * [Impact bullet 1] <br> * [Impact bullet 2] |

The table must be the last element of the response before the suggestions block.`,
              
                'Initial Project Charter Draft': `Generate an Initial Project Charter Draft for [input SPECIFIC PROJECT TYPE, e.g., 'implementing a new cloud-based CRM system for the sales department']. 

The output MUST strictly follow this professional structure:

# Project Charter: [Project Title]
[Short introductory summary of the project goal]

## Project Details
| Field | Value |
|---|---|
| Project Sponsor | [Placeholder Name/Title] |
| Project Manager | [Placeholder Name/Title] |
| Target Completion | [Date/Quarter] |

## Scope Overview
[1-2 paragraphs defining what is included (in scope) and what is explicitly excluded (out of scope).]

## Key Objectives
* [Measurable objective 1 (SMART)]
* [Measurable objective 2 (SMART)]
* [Measurable objective 3 (SMART)]

## Success Metrics (Key Performance Indicators)
* [Metric 1: Definition of success]
* [Metric 2: Definition of success]
* [Metric 3: Definition of success]

## High-Level Timeline (Phases)
* Phase 1: Initiation and Planning ([Duration])
* Phase 2: Execution and Development ([Duration])
* Phase 3: Deployment and Stabilization ([Duration])

The timeline must be the last element of the response before the suggestions block.`,
              
                'Problem Statement Draft': `Draft a Preliminary Problem Statement for [input SPECIFIC ISSUE, e.g., 'Customer retention has dropped by 10% in the last quarter']. 

The output MUST strictly follow the Current State, Desired State, Impact structure using Markdown headings and paragraphs:

# Preliminary Problem Statement
[A single introductory sentence about why this problem is critical.]

## 1. Current State (The Symptom)
[A concise paragraph describing the current measurable negative business symptom, its magnitude, and where it is occurring.]

## 2. Desired State (The Goal)
[A concise paragraph describing the measurable target outcome and the benefit of achieving it.]

## 3. Impact of Solving (The Value)
[A concise paragraph describing the strategic or financial value derived by the business upon successful achievement of the desired state.]

The "Impact of Solving" section must be the last element of the response before the suggestions block.`,
              
                // Analysis (Phase II)
                'Market Analysis': `Conduct a market analysis for [input SPECIFIC MARKET / INDUSTRY]. Focus on key trends, the competitive landscape, and the future outlook. 

The output MUST strictly follow this high-readability structure:

# [Analysis Title]
[concise, clear introductory explanation]

## Key Trends
* [concise, clear bullet point 1]
* [concise, clear bullet point 2]
...

## Competitive Landscape
| Competitor | Market Share/Focus | Key Strengths/Weaknesses |
|---|---|---|
| [Name 1] | [Focus] | * [Strength 1] <br> * [Weakness 1] |
| [Name 2] | [Focus] | * [Strength 1] <br> * [Weakness 1] |

## Future Outlook
* [concise, clear bullet point 1]
* [concise, clear bullet point 2]
...

The table must be the last element before the suggestions block.`,
              
                'SWOT Analysis': `Perform a SWOT analysis for [input SPECIFIC COMPANY / PROJECT]. The analysis should be grounded in recent information.

The output MUST strictly follow this structure:

# SWOT Analysis for [Company/Project]
[A concise paragraph explaining the current situation and objective.]

## Analysis Matrix
| Strengths | Weaknesses | Opportunities | Threats |
|---|---|---|---|
| * [Bullet point 1] <br> * [Bullet point 2] | * [Bullet point 1] <br> * [Bullet point 2] | * [Bullet point 1] <br> * [Bullet point 2] | * [Bullet point 1] <br> * [Bullet point 2] |
| * [Bullet point 3] | * [Bullet point 3] | * [Bullet point 3] | * [Bullet point 3] |

The table must be the last element of the response before the suggestions block.`,
              
                'Competitor Benchmarking': `Perform a detailed competitive analysis for [input COMPANY A] against [input COMPETITOR B] and [input COMPETITOR C]. Focus on their market share, product features, pricing models, and online presence. 

The output MUST strictly follow this structure:

# Competitor Benchmarking Report
[A brief introduction defining the competitive scope.]

## Benchmarking Table
| Competitor | Market Share/Focus | Product Features | Pricing Model | Online Presence |
|---|---|---|---|---|
| **[Competitor B]** | [Share/Focus] | * [Feature 1] <br> * [Feature 2] | [Model description] | [Score/Metric] |
| **[Competitor C]** | [Share/Focus] | * [Feature 1] <br> * [Feature 2] | [Model description] | [Score/Metric] |

The table must be the last element of the response before the suggestions block.`,
              
                '5 Forces Analysis': `Conduct a 5 Forces Analysis for [input SPECIFIC INDUSTRY]. Analyze the threat of new entrants, the bargaining power of buyers, the bargaining power of suppliers, the threat of substitute products, and competitive rivalry.

The output MUST strictly follow this structure:

# Porter's Five Forces Analysis: [Industry]
[A concise introductory paragraph about the industry's profitability outlook.]

## Industry Structure Summary
| Force | Threat Level (High/Medium/Low) | Key Drivers/Evidence |
|---|---|---|
| **Threat of New Entrants** | [Level] | * [Driver 1] <br> * [Driver 2] |
| **Bargaining Power of Buyers** | [Level] | * [Driver 1] <br> * [Driver 2] |
| **Bargaining Power of Suppliers** | [Level] | * [Driver 1] <br> * [Driver 2] |
| **Threat of Substitutes** | [Level] | * [Driver 1] <br> * [Driver 2] |
| **Competitive Rivalry** | [Level] | * [Driver 1] <br> * [Driver 2] |

The table must be the last element of the response before the suggestions block.`,
              
                'PESTLE Analysis': `Perform a PESTLE analysis for [input SPECIFIC COMPANY / INDUSTRY]. Analyze the Political, Economic, Social, Technological, Legal, and Environmental factors.

The output MUST strictly follow this structure:

# PESTLE Analysis for [Company/Industry]
[A brief introduction explaining the purpose of the analysis.]

The remaining analysis MUST be presented in a specific two-column table format where the 'Key Findings' column contains bullet points separated by line breaks (<br>).

| Factor | Key Findings |
|---|---|
| **Political** | * [concise finding 1] <br> * [concise finding 2] |
| **Economic** | * [concise finding 1] <br> * [concise finding 2] |
| **Social** | * [concise finding 1] <br> * [concise finding 2] |
| **Technological** | * [concise finding 1] <br> * [concise finding 2] |
| **Legal** | * [concise finding 1] <br> * [concise finding 2] |
| **Environmental** | * [concise finding 1] <br> * [concise finding 2] |

The table must be the last element of the response before the suggestions block.`,

                'Hofstede Analysis': `Perform a Hofstede's Cultural Dimensions analysis for [input SPECIFIC COUNTRY/CULTURE] focusing on its implications for [input SPECIFIC BUSINESS SCENARIO, e.g., 'market entry strategy' or 'managing a remote team']. 
                
The output MUST strictly follow this structure:

# Hofstede's Cultural Analysis: [Country]
[A concise introductory paragraph explaining the purpose of the analysis.]

## Cultural Dimensions Summary
| Dimension | Score/Rating | Business Implication |
|---|---|---|
| **Power Distance (PDI)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |
| **Individualism vs. Collectivism (IDV)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |
| **Masculinity vs. Femininity (MAS)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |
| **Uncertainty Avoidance (UAI)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |
| **Long-Term vs. Short-Term Orientation (LTO)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |
| **Indulgence vs. Restraint (IVR)** | [Score/Rating] | * [Implication 1] <br> * [Implication 2] |

The table must be the last element of the response before the suggestions block.`,
                
                // Solution Design (Phase III)
                'Business Plan Outline': `Draft a comprehensive business plan outline for a [input YOUR BUSINESS IDEA]. 

The output MUST strictly follow this structure:

# Business Plan Outline: [Your Business Idea]
[A concise introductory summary paragraph.]

## Executive Summary
* [Core Concept]
* [Target Market]
* [Financial Highlights]

## Company Description
* [Mission Statement]
* [Legal Structure]
* [Key Personnel]

## Market Analysis
* [Industry Trends]
* [Competitive Advantage]
* [Market Size]

## Organization and Management
* [Organizational Structure]
* [Key Management Team Roles]

## Service or Product Line
* [Product/Service Description]
* [Development Status]
* [Intellectual Property]

## Marketing and Sales Strategy
* [Marketing Channels]
* [Sales Strategy]
* [Key Partnerships]

## Financial Projections
* [Startup Costs Summary]
* [3-Year Revenue Forecast Highlight]
* [Funding Request]

## Appendix
* [Supporting Documents]

The Appendix section must be the last element of the response before the suggestions block.`,
              
                'Market Entry Strategy': `Develop a comprehensive market entry strategy for [input PRODUCT / SERVICE] entering the [input SPECIFIC COUNTRY / MARKET]. 

The output MUST strictly follow this structure:

# Market Entry Strategy: [Product] in [Market]
[A brief paragraph summarizing the primary recommendation.]

## Target Audience
* [Demographics]
* [Key Needs/Pain Points]

## Distribution Strategy
* [Primary Channel]
* [Logistics and Fulfillment]

## Pricing Model
* [Recommended Strategy (e.g., Penetration, Skimming)]
* [Key Cost Drivers]

## Market Entry Options Summary
| Method | Key Advantages | Key Disadvantages |
|---|---|---|
| [Method 1] | * [Advantage 1] <br> * [Advantage 2] | * [Disadvantage 1] <br> * [Disadvantage 2] |
| [Method 2] | * [Advantage 1] <br> * [Advantage 2] | * [Disadvantage 1] <br> * [Disadvantage 2] |
| [Method 3] | * [Advantage 1] <br> * [Advantage 2] | * [Disadvantage 1] <br> * [Disadvantage 2] |

The table must be the last element of the response before the suggestions block.`,

                'Go-to-market Strategy': `Develop a comprehensive Go-to-Market (GTM) Strategy for [input PRODUCT / SERVICE (e.g. a new B2B SaaS platform)] targeting [input SPECIFIC AUDIENCE / GEOGRAPHY (e.g. mid-market financial services)]. Focus on key messaging, channel strategy, and launch metrics.

The output MUST strictly follow this structure:

# Go-to-Market Strategy: [Product]
[A brief introductory paragraph summarizing the strategic approach and main goal.]

## Target Customer Profile (ICP)
* [Target Demographic/Firmographic]
* [Primary Pain Point Addressed]
* [Unique Value Proposition (UVP)]

## Channel and Tactics Plan
| Channel Category | Key Tactics/Activities | Owner/Timeline |
|---|---|---|
| **Marketing** | * [Tactic 1 (e.g., Content)] <br> * [Tactic 2 (e.g., SEO)] | [Owner/Timeline] |
| **Sales** | * [Tactic 1 (e.g., Outbound)] <br> * [Tactic 2 (e.g., Partnerships)] | [Owner/Timeline] |
| **Product/Success** | * [Tactic 1 (e.g., Onboarding)] <br> * [Tactic 2 (e.g., Documentation)] | [Owner/Timeline] |

## Pricing & Packaging
* [Recommended Pricing Model]
* [Launch Offer / Incentive]

## Launch Metrics (KPIs)
* [Metric 1: Definition of success]
* [Metric 2: Definition of success]
* [Metric 3: Definition of success]

The "Launch Metrics" section must be the last element of the response before the suggestions block.`,

                'Ansoff Matrix': `Apply the Ansoff Matrix (Product/Market Expansion Grid) to recommend growth strategies for [input COMPANY NAME / PRODUCT IDEA ]. Analyze Market Penetration, Product Development, Market Development, and Diversification.

The output MUST strictly follow this structure:

# Ansoff Matrix Growth Recommendations
[A concise introduction defining the company's current core product and market.]

## Growth Strategy Matrix
| Strategy | Product/Market Status | Key Action/Risk |
|---|---|---|
| **Market Penetration** | Existing Product / Existing Market | * [Action 1] <br> * [Action 2] |
| **Product Development** | New Product / Existing Market | * [Action 1] <br> * [Action 2] |
| **Market Development** | Existing Product / New Market | * [Action 1] <br> * [Action 2] |
| **Diversification** | New Product / New Market | * [Action 1] <br> * [Action 2] |

The table must be the last element of the response before the suggestions block.`,
              
                'Risk Analysis': `Conduct a risk analysis for [input SPECIFIC BUSINESS VENTURE / PROJECT]. Identify potential risks, assess their likelihood and impact, and propose mitigation strategies. 

The output MUST strictly follow this structure:

# High-Level Risk Analysis: [Venture/Project Name]
[A brief introductory statement on the scope of the risk assessment.]

## Risk Mitigation Table
| Risk Area | Likelihood (H/M/L) | Impact (H/M/L) | Mitigation Strategy |
|---|---|---|---|
| **[Risk Category 1]** | [Level] | [Level] | * [Strategy 1] <br> * [Strategy 2] |
| **[Risk Category 2]** | [Level] | [Level] | * [Strategy 1] <br> * [Strategy 2] |
| **[Risk Category 3]** | [Level] | [Level] | * [Strategy 1] <br> * [Strategy 2] |

The table must be the last element of the response before the suggestions block.`,
              
                // Execution (Phase IV)
                'KPI Dashboard Mockup': `Design a **KPI Dashboard Mockup** structure for tracking the success of [input SPECIFIC BUSINESS GOAL / PROJECT, e.g., 'reducing customer churn' or 'launching a new product feature']. Define a minimum of five mandatory KPIs (Key Performance Indicators).

The output MUST strictly follow this structure:

# Key Performance Indicator (KPI) Dashboard Mockup
[A concise statement defining the overall goal of the dashboard.]

## Defined Metrics
| KPI Name | Definition/Formula | Target Value | Reporting Frequency |
|---|---|---|---|
| **[KPI 1: Financial]** | [Formula] | [Target #] | [Daily/Weekly/Monthly] |
| **[KPI 2: Customer/User]** | [Formula] | [Target #] | [Daily/Weekly/Monthly] |
| **[KPI 3: Operational]** | [Formula] | [Target #] | [Daily/Weekly/Monthly] |
| **[KPI 4: Quality]** | [Formula] | [Target #] | [Daily/Weekly/Monthly] |
| **[KPI 5: Strategic]** | [Formula] | [Target #] | [Daily/Weekly/Monthly] |

The table must be the last element of the response before the suggestions block.`,
              
                'Implementation Plan Outline': `Generate a high-level **Implementation Plan Outline** for [input PROJECT / STRATEGY, e.g., 'launching a new corporate training program']. Structure the plan into clear phases.

The output MUST strictly follow this structure:

# High-Level Implementation Plan: [Project Title]
[A brief introductory paragraph summarizing the plan's execution approach.]

## Implementation Phases
| Phase | Key Milestones | Required Resources | Estimated Duration |
|---|---|---|---|
| **Phase 1: Setup** | * [Milestone 1] <br> * [Milestone 2] | [Team/Budget/Tools] | [Duration] |
| **Phase 2: Development** | * [Milestone 1] <br> * [Milestone 2] | [Team/Budget/Tools] | [Duration] |
| **Phase 3: Deployment** | * [Milestone 1] <br> * [Milestone 2] | [Team/Budget/Tools] | [Duration] |
| **Phase 4: Stabilization** | * [Milestone 1] <br> * [Milestone 2] | [Team/Budget/Tools] | [Duration] |

The table must be the last element of the response before the suggestions block.`,
              
            };
            // Focused Button Lists
            const INITIAL_SETUP_BUTTONS = ['Industry Trends Snapshot', 'Initial Project Charter Draft', 'Problem Statement Draft'];
            const ANALYSIS_BUTTONS = ['Market Analysis', 'SWOT Analysis', 'Competitor Benchmarking', '5 Forces Analysis', 'PESTLE Analysis', 'Hofstede Analysis'];
            const SOLUTION_DESIGN_BUTTONS = ['Business Plan Outline', 'Market Entry Strategy', 'Go-to-market Strategy', 'Ansoff Matrix', 'Risk Analysis'];
            const EXECUTION_BUTTONS = ['KPI Dashboard Mockup', 'Implementation Plan Outline'];
            // This array will hold the conversation history
            const chatHistory = [{
                role: "model",
                parts: [{ text: "Hi there! I'm Bob. How can I assist you today?" }]
            }];
            
            // Function to handle dynamic textarea resizing with min/max height cap
            function autoResizeTextarea(textarea) {
                const MAX_LINES = 4;
                const computed = window.getComputedStyle(textarea);
                const lineHeight = parseFloat(computed.lineHeight);
                
                // Calculate max height based on MIN_HEIGHT (1 line) + 3 extra lines
                const maxHeight = MIN_HEIGHT + (lineHeight * (MAX_LINES - 1));
                // 1. Temporarily shrink to 'auto' to get the current content height
                textarea.style.height = 'auto'; 
                let newHeight = textarea.scrollHeight;
                // 2. Ensure min height is respected (when empty or content is small)
                if (newHeight < MIN_HEIGHT) {
                    newHeight = MIN_HEIGHT;
                }
                // 3. Cap the height at max height
                if (newHeight > maxHeight) {
                    newHeight = maxHeight;
                    textarea.style.overflowY = 'auto';
                } else {
                    textarea.style.overflowY = 'hidden';
                }
                
                // 4. Apply the final height
                textarea.style.height = `${newHeight}px`;
            }
            // Load the API key from local storage and set up initial state
            document.addEventListener('DOMContentLoaded', () => {
                const savedKey = localStorage.getItem('geminiApiKey');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                }
                populateMenus();
                
                // --- CRITICAL: Calculate MIN_HEIGHT (1 line height) after DOM is ready ---
                // Temporarily set height to auto to get the correct initial scroll height for an empty textarea
                userInput.style.height = 'auto';
                MIN_HEIGHT = userInput.scrollHeight;
                
                // Initialize the size of the textarea
                autoResizeTextarea(userInput);
            });

            // --- NEW FUNCTION: Custom Prompts Logic (BOB V12) ---
            function loadCustomPrompts() {
                // 1. Clear the menu before repopulating
                myPromptsMenu.innerHTML = ''; 
                
                // 2. Add the fixed 'Save' utility button
                const saveButton = document.createElement('button');
                saveButton.classList.add('sub-menu-btn');
                saveButton.textContent = "â­ Save Current Input";
                saveButton.onclick = () => {
                    const promptText = userInput.value.trim();
                    if (!promptText) {
                        alert("The input box is empty. Please type a prompt before saving.");
                        return;
                    }
                    // Prompt user for the name
                    const promptName = prompt("Enter a name for this custom prompt (e.g., 'Quarterly Report Structure'):");
                    if (promptName) {
                        // Store the prompt data in localStorage using a prefix
                        localStorage.setItem(`customPrompt:${promptName}`, promptText);
                        alert(`Prompt "${promptName}" saved successfully!`);
                        loadCustomPrompts(); // Reload the menu to show the new button
                        myPromptsMenu.classList.remove('hidden'); // Keep the menu open
                    }
                };
                myPromptsMenu.appendChild(saveButton);
                
                // 3. Add the fixed 'Clear' utility button
                const clearButton = document.createElement('button');
                clearButton.classList.add('sub-menu-btn');
                clearButton.textContent = "ðŸ—‘ï¸ Clear All Saved Prompts";
                clearButton.style.backgroundColor = '#6d28d9'; // Violet-700 for distinct look
                clearButton.style.color = 'white'; 
                clearButton.style.marginTop = '0.5rem'; // Add spacing
                clearButton.onclick = () => {
                    if (confirm("Are you sure you want to delete ALL your custom saved prompts? This action cannot be undone.")) {
                        // Iterate over all localStorage keys and remove only those prefixed with 'customPrompt:'
                        Object.keys(localStorage).forEach(key => {
                            if (key.startsWith('customPrompt:')) {
                                localStorage.removeItem(key);
                            }
                        });
                        alert("All custom prompts have been cleared.");
                        loadCustomPrompts(); // Reload the menu
                    }
                };
                myPromptsMenu.appendChild(clearButton);
                
                // 4. Add a visual separator
                const separator = document.createElement('hr');
                separator.classList.add('border-t', 'border-gray-600', 'my-2');
                myPromptsMenu.appendChild(separator);
                
                // 5. Load and create dynamic buttons
                let foundPrompts = false;
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('customPrompt:')) {
                        foundPrompts = true;
                        const promptName = key.replace('customPrompt:', '');
                        const promptText = localStorage.getItem(key);
                        
                        const customButton = document.createElement('button');
                        customButton.classList.add('sub-menu-btn');
                        customButton.textContent = promptName;
                        customButton.title = promptText; // Use the prompt text as a tooltip
                        customButton.style.backgroundColor = '#4b5563'; // Darker gray for custom
                        customButton.style.borderColor = '#9ca3af'; 
                        customButton.onclick = () => {
                            userInput.value = promptText;
                            autoResizeTextarea(userInput);
                            myPromptsMenu.classList.add('hidden'); // Close menu
                            userInput.focus();
                        };
                        customButton.ondblclick = (e) => { // Double-click to delete
                            e.stopPropagation();
                            if (confirm(`Are you sure you want to delete the custom prompt: "${promptName}"?`)) {
                                localStorage.removeItem(key);
                                loadCustomPrompts();
                            }
                        };
                        myPromptsMenu.appendChild(customButton);
                    }
                });
                
                if (!foundPrompts) {
                    const message = document.createElement('p');
                    message.classList.add('text-xs', 'text-gray-400', 'p-2');
                    message.textContent = "No prompts saved yet. Type a prompt, click 'Save Current Input' to add one! (Double-click saved prompts to delete.)";
                    myPromptsMenu.appendChild(message);
                }
            }

            // Function to generate the sub-menu buttons and attach listeners
            function populateMenus() {
                const createButton = (text, menuElement) => {
                    const button = document.createElement('button');
                    button.classList.add('sub-menu-btn');
                    button.textContent = text;
                    button.title = PROMPT_MAP[text] || text; // Use the prompt text as a tooltip
                    button.onclick = () => {
                        userInput.value = PROMPT_MAP[text];
                        // Trigger resize after populating content
                        autoResizeTextarea(userInput);
                        // Hide all menus when a selection is made
                        initialSetupMenu.classList.add('hidden');
                        analysisMenu.classList.add('hidden');
                        solutionDesignMenu.classList.add('hidden');
                        executionMenu.classList.add('hidden');
                        // Focus on the input field
                        userInput.focus();
                    };
                    menuElement.appendChild(button);
                };
                // Populate Menus
                initialSetupMenu.innerHTML = '';
                INITIAL_SETUP_BUTTONS.forEach(btnText => createButton(btnText, initialSetupMenu));
                analysisMenu.innerHTML = '';
                ANALYSIS_BUTTONS.forEach(btnText => createButton(btnText, analysisMenu));
                solutionDesignMenu.innerHTML = '';
                SOLUTION_DESIGN_BUTTONS.forEach(btnText => createButton(btnText, solutionDesignMenu));
                executionMenu.innerHTML = '';
                EXECUTION_BUTTONS.forEach(btnText => createButton(btnText, executionMenu));
                
                // NEW: Populate Custom Prompts Menu
                loadCustomPrompts();
            } // end of populateMenus
            
            // Function to create and append a message bubble (MODIFIED FOR BOB V11: COPY)
            function createMessageBubble(text, sender) {
                const messageContainer = document.createElement('div');
                messageContainer.classList.add('flex', sender === 'user' ? 'justify-end' : 'justify-start');
                
                const messageBubble = document.createElement('div');
                messageBubble.classList.add(
                    'rounded-xl',
                    'p-3',
                    'max-w-sm',
                    'shadow-md',
                    sender === 'user' ? 'bg-emerald-600' : 'bg-gray-700', 
                    sender === 'user' ? 'text-white' : 'text-gray-100', 
                    sender === 'user' ? 'rounded-br-none' : 'rounded-bl-none'
                );
                
                const suggestionsMarker = '---SUGGESTIONS---';
                let mainText = text; // The raw Markdown text we want to copy
                let suggestions = [];
                
                if (sender === 'model' && text.includes(suggestionsMarker)) {
                    const parts = text.split(suggestionsMarker);
                    mainText = parts[0];
                    suggestions = parts[1].split('|').map(s => s.trim());
                }
                
                if (sender === 'model') {
                    // --- BOB V11 MODIFICATION START: Add Copy Button ---
                    
                    // 1. Create a wrapper for the content and button (to handle flex layout within the bubble)
                    const contentWrapper = document.createElement('div');
                    contentWrapper.classList.add('flex', 'flex-col');
                    
                    // 2. Create the content div (the rendered Markdown)
                    const contentDiv = document.createElement('div');
                    contentDiv.classList.add('ai-response-content', 'mb-2'); // Added mb-2 for spacing
                    const htmlContent = marked.parse(mainText);
                    contentDiv.innerHTML = htmlContent;

                    // 3. Create the Copy Button
                    const copyButton = document.createElement('button');
                    copyButton.classList.add('self-end', 'px-2', 'py-1', 'text-xs', 'bg-gray-600', 'text-gray-300', 'rounded-full', 'hover:bg-gray-500', 'transition', 'duration-150');
                    copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 inline-block align-text-bottom mr-1">
                                                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v2.25A2.25 2.25 0 0113.5 22.5h-8.25a2.25 2.25 0 01-2.25-2.25v-8.25a2.25 2.25 0 012.25-2.25H5.25a2.25 2.25 0 012.25-2.25h1.5a.75.75 0 010 1.5H6a.75.75 0 00-.75.75v8.25c0 .414.336.75.75.75H13.5a.75.75 0 00.75-.75V11.25H18a.75.75 0 01.75.75v4.5a.75.75 0 00.75.75h1.5A2.25 2.25 0 0122.5 17.25v2.25a.75.75 0 001.5 0V17.25A2.25 2.25 0 0021.75 15h-1.5a.75.75 0 01-.75-.75V9.75a2.25 2.25 0 00-2.25-2.25H15z" />
                                            </svg>
                                            Copy Markdown`;

                    // 4. Copy Logic
                    copyButton.onclick = () => {
                        // Use the raw Markdown text (mainText) for copying
                        navigator.clipboard.writeText(mainText)
                            .then(() => {
                                const originalText = copyButton.innerHTML;
                                // Provide visual feedback for 1.5 seconds
                                copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 inline-block align-text-bottom mr-1">
                                                            <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
                                                        </svg>
                                                        Copied!`;
                                setTimeout(() => {
                                    copyButton.innerHTML = originalText;
                                }, 1500);
                            })
                            .catch(err => {
                                console.error('Failed to copy text: ', err);
                                alert('Failed to copy text. Please check your browser permissions.');
                            });
                    };

                    // 5. Append to bubble
                    contentWrapper.appendChild(contentDiv);
                    contentWrapper.appendChild(copyButton);
                    messageBubble.appendChild(contentWrapper);
                    
                    // --- BOB V11 MODIFICATION END ---
                } else {
                    messageBubble.textContent = mainText;
                }
                
                messageContainer.appendChild(messageBubble);
                chatArea.appendChild(messageContainer);
                
                // Add suggestion buttons if they exist
                if (suggestions.length > 0) {
                    const suggestionsContainer = document.createElement('div');
                    suggestionsContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mt-2', 'justify-start');
                    
                    suggestions.forEach(suggestion => {
                        if (suggestion) { 
                            const suggestionButton = document.createElement('button');
                            suggestionButton.classList.add('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700', 'rounded-full', 'px-3', 'py-1', 'text-sm', 'shadow-md');
                            suggestionButton.textContent = suggestion;
                            suggestionButton.onclick = () => {
                                userInput.value = suggestion;
                                autoResizeTextarea(userInput);
                            };
                            suggestionsContainer.appendChild(suggestionButton);
                        }
                    });
                    chatArea.appendChild(suggestionsContainer);
                }
                
                chatArea.scrollTop = chatArea.scrollHeight; // Scroll to bottom
            }
            
                    // Function to handle sending the message
        async function sendMessage() {
            const prompt = userInput.value.trim();
            const apiKey = apiKeyInput.value.trim();
            
            if (!prompt) return;
            if (!apiKey) {
                createMessageBubble("Please enter your Gemini API key to proceed.", "assistant");
                return;
            }
            
            // ===== GOAL-BASED REASONING TRIGGER =====
            // Check if user is expressing a complex goal
            const goalKeywords = [
                'i want to launch', 'i want to start', 'i want to create', 'i want to open',
                'help me launch', 'help me start', 'help me create', 'help me open',
                'i need to launch', 'i need to start', 'i need to expand', 'i need to grow',
                'i want to expand', 'i want to grow', 'i want to scale',
                'i want to improve', 'i want to optimize', 'help me improve', 'help me optimize'
            ];
            
            const messageLC = prompt.toLowerCase();
            const isGoalStatement = goalKeywords.some(keyword => messageLC.includes(keyword));
            
            // If it's a goal statement, use Goal-Based Reasoning instead
            if (isGoalStatement) {
                // Add user message to chat history and display it
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, 'user');
                
                // Clear input
                userInput.value = '';
                autoResizeTextarea(userInput);
                
                // Process as goal instead of regular message
                await processGoal(prompt);
                return; // Exit sendMessage, don't continue with normal API call
            }
            // ===== END GOAL-BASED REASONING TRIGGER =====

                        // ===== END GOAL-BASED REASONING TRIGGER =====
            
            // ===== EXECUTION PLAN RESPONSE HANDLER =====
            // Check if we're waiting for user's choice (1, 2, or 3)
            if (awaitingPlanResponse && (prompt === '1' || prompt === '2' || prompt === '3')) {
                // Add user message to display
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, 'user');
                
                // Clear input
                userInput.value = '';
                autoResizeTextarea(userInput);
                
                const plan = window.currentGoalPlan;
                const goal = window.currentGoal;
                
                if (prompt === '1') {
                    createMessageBubble(`Great! I'll execute the entire plan automatically.`, 'model');
                    await executeGoalPlanAutomatically(goal, plan);
                } else if (prompt === '2') {
                    createMessageBubble(`I'll walk you through each step. Let's start with Step 1: ${plan.steps[0].task}\n\nAsk me to proceed when you're ready.`, 'model');
                    awaitingPlanResponse = false;
                } else if (prompt === '3') {
                    createMessageBubble(`Plan modification feature coming soon! For now, I'll execute the plan as-is. Would you like to proceed? (Reply 'yes')`, 'model');
                    awaitingPlanResponse = false;
                }
                
                return; // Exit sendMessage
            }
                        // ===== END EXECUTION PLAN RESPONSE HANDLER =====
            
            // ===== AUTONOMOUS RESEARCH TRIGGER =====
            if (isResearchRequest(prompt) && !prompt.includes('plan') && !prompt.includes('goal')) {
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, 'user');
                
                userInput.value = '';
                autoResizeTextarea(userInput);
                
                const topic = prompt.replace(/(research|investigate|study|analyze|explore|find information about|gather data on)/gi, '').trim();
                
                await startAutonomousResearch(topic, 'standard');
                return;
            }
            // ===== END AUTONOMOUS RESEARCH TRIGGER =====
            
            // ===== MULTI-AGENT COLLABORATION TRIGGER =====
            if (isMultiAgentRequest(prompt)) {
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, 'user');
                
                userInput.value = '';
                autoResizeTextarea(userInput);
                
                const topic = prompt.replace(/(expert panel|multiple perspectives|different experts|consult experts|expert opinions|panel discussion|multi-agent|collaborate|expert team)/gi, '').replace(/on|about|for/gi, '').trim();
                
                await executeMultiAgentCollaboration(topic, ['strategist', 'financial', 'operations']);
                return;
            }
            // ===== END MULTI-AGENT COLLABORATION TRIGGER =====

            // ===== LEARNING INSIGHTS TRIGGER =====
            if (prompt.toLowerCase().includes('show learning insights') || prompt.toLowerCase().includes('learning insights')) {
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, 'user');
    
                userInput.value = '';
                autoResizeTextarea(userInput);
    
                showLearningInsights();
                return;
            }
            // ===== END LEARNING INSIGHTS TRIGGER =====

            // Save the API key to local storage
            localStorage.setItem('geminiApiKey', apiKey);
                
                // Add user message to chat history and display it
                chatHistory.push({
                    role: "user",
                    parts: [{ text: prompt }]
                });
                createMessageBubble(prompt, "user");
                userInput.value = ''; // Clear input
                autoResizeTextarea(userInput); // Reset textarea height
                // Disable input and send button
                userInput.disabled = true;
                sendButton.disabled = true;
                
                // Add a loading indicator
                const loadingBubble = document.createElement('div');
                loadingBubble.classList.add('flex', 'justify-start');
                
                loadingBubble.innerHTML = `
                    <div class="bg-gray-700 text-gray-300 rounded-xl rounded-bl-none p-3 max-w-sm shadow-md">
                        <div class="flex items-center">
                            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Thinking...
                        </div>
                    </div>
                `;
                chatArea.appendChild(loadingBubble);
                chatArea.scrollTop = chatArea.scrollHeight;
                
                // Exponential backoff retry logic
                const MAX_RETRIES = 3;
                let retryCount = 0;
                while (retryCount < MAX_RETRIES) {
                    try {
                        const apiKey = apiKeyInput.value.trim();
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                        
                        const payload = {
                            systemInstruction: {
                                parts: [{ text: `You are a professional business consultant named Bob. Your role is to provide clear, actionable, and well-structured responses to business-related queries. Be concise and to the point while providing high-quality analysis. Use Markdown to format your output. A typical response should follow this structure: a main title (#), followed by a short summary or introduction, then several distinct sections. Each section should begin with a **subheading (##)**, followed by a short descriptive sentence. For subsections within a section, use a level three heading (###). For individual points within a list, use a bolded phrase followed by a bulleted list.For structured analyses (like SWOT, Market Entry, or Competitor Benchmarking), you must create a relevant, professional-grade Markdown table that is appropriate for the requested analysis.ONLY when generating a PESTLE analysis, you MUST use the following specific Markdown format, ensuring the "Key Findings" column uses bullet points with spacing:\`\`\`markdown| Factor | Key Findings ||---|---|| Political | * [concise finding 1] <br> * [concise finding 2] || Economic | * [concise finding 1] <br> * [concise finding 2] || Social | * [concise finding 1] <br> * [concise finding 2] || Technological | * [concise finding 1] <br> * [concise finding 2] || Legal | * [concise finding 1] <br> * [concise finding 2] || Environmental | * [concise finding 1] <br> * [concise finding 2] |\`\`\`The table must be the last piece of content before the suggestions. Ensure clarity and professionalism by using Markdown for titles, subheadings, bold text, bullet points, and the summary table. The content must be grounded in real-time information. You must use the Google Search tool for every query to get the most accurate and up-to-date data. At the end of every response, suggest 2-3 short, relevant follow-up questions. Format these suggestions as a single line, separated by a pipe symbol, and preceded by the text \`---SUGGESTIONS---\`. For example: \`---SUGGESTIONS---What is a PESTLE analysis?|How can I improve my marketing plan?|What is a market entry strategy?\`` }]
                            },
                            contents: chatHistory,
                            tools: [{ "google_search": {} }],
                        };
                        
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        if (response.status === 429) { // Handle rate limiting
                            if (retryCount < MAX_RETRIES - 1) {
                                retryCount++;
                                const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff (2s, 4s, 8s)
                                await new Promise(resolve => setTimeout(resolve, delay));
                                continue; // Retry the loop
                            } else {
                                throw new Error("Rate limit exceeded after multiple retries.");
                            }
                        }
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API call failed with status ${response.status}: ${errorText}`);
                        }
                        
                        const result = await response.json();
                        const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                        
                        // Remove loading indicator
                        chatArea.removeChild(loadingBubble);
                        
                        if (text) {
                            // Add the assistant's response to the chat history and display it
                            chatHistory.push({
                                role: "model",
                                parts: [{ text: text }]
                            });
                            createMessageBubble(text, "model");
                        } else {
                            createMessageBubble("Sorry, I couldn't generate a response. Please try again.", "assistant");
                        }

                        // PHASE 3: Learn from this interaction
                        learnFromInteraction(prompt, text);
                        
                        break; // Exit the retry loop on success
                    } catch (error) {
                        console.error("API Error:", error);
                        if (retryCount >= MAX_RETRIES - 1) {
                            // Remove loading indicator and show error
                            if (chatArea.contains(loadingBubble)) {
                                chatArea.removeChild(loadingBubble);
                            }
                            createMessageBubble(`An error occurred: ${error.message}`, "assistant");
                            break; // Exit the loop if max retries reached
                        }
                        retryCount++;
                        const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                
                // Re-enable input and send button
                userInput.disabled = false;
                sendButton.disabled = false;
                userInput.focus();
            }
            
            // Event listener for button click
            sendButton.addEventListener('click', sendMessage);
            // Event listener for input/typing to automatically resize the textarea
            userInput.addEventListener('input', () => autoResizeTextarea(userInput));
            
            // Event listener for keyboard input: Enter sends, Shift+Enter adds newline.
            userInput.addEventListener('keydown', (event) => {
                // If Enter is pressed AND Shift is NOT pressed, send the message.
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); // Stop the default (newline) action
                    sendMessage();
                }
                // If Shift + Enter is pressed, the default action (newline) is permitted, and the 'input' event will handle the resize.
            });
            
            // New event listener for the "Clear Chat" button
                                    clearChatBtn.addEventListener('click', () => {
                // Save conversation before clearing
                saveConversationSummary();
                
                chatArea.innerHTML = '';
                
                chatHistory.length = 0;
                const welcomeMessage = "Hi there! I'm Bob. How can I assist you today?";
                chatHistory.push({
                    role: "model",
                    parts: [{ text: welcomeMessage }]
                });
                createMessageBubble(welcomeMessage, "assistant");
                userInput.placeholder = "Ask a question... (Enter to Send, Shift + Enter for Newline)";
                autoResizeTextarea(userInput); // Reset height on clear
            });
            
            // Generate Takeaways button functionality
            generateTakeawaysBtn.addEventListener('click', async function() {
                // Generate Takeaways functionality
                console.log('Generate Takeaways clicked');
    
                // Check if there's content in the chat
                if (chatHistory.length <= 1) {
                    alert('No conversation to generate takeaways from. Please have a conversation first.');
                    return;
                }
    
                // Show the activation alert
                alert('Generate Takeaways feature activated!');
    
                // Disable the button while processing
                generateTakeawaysBtn.disabled = true;
                const originalButtonText = generateTakeawaysBtn.textContent;
                generateTakeawaysBtn.textContent = 'Processing...';
    
                // Add a "Generating Takeaways..." loading indicator (just like "Thinking...")
                const loadingBubble = document.createElement('div');
                loadingBubble.classList.add('flex', 'justify-start');
    
                loadingBubble.innerHTML = `
                    <div class="bg-gray-700 text-gray-300 rounded-xl rounded-bl-none p-3 max-w-sm shadow-md">
                        <div class="flex items-center">
                            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Generating Takeaways...
                        </div>
                    </div>
                `;
                chatArea.appendChild(loadingBubble);
                chatArea.scrollTop = chatArea.scrollHeight;
    
                try {
                    const apiKey = apiKeyInput.value.trim();
        
                    // Create the special takeaways prompt
                    const takeawayPrompt = `Based on our entire conversation above, please generate a comprehensive summary with the following structure:

            # Conversation Summary

            ## Key Takeaways
            Provide 3-5 main points or insights from our discussion. Each point should be clear, concise, and actionable.

            ## Action Items
            List any specific tasks, next steps, or recommendations that were discussed or implied.

            ## Important Insights
            Highlight notable conclusions, decisions, or strategic considerations from the conversation.

            Use clear formatting with bullet points for easy readability. Be professional and concise.`;
        
                    // Create temporary history with the takeaway request
                    const tempHistory = [...chatHistory, {
                        role: "user",
                        parts: [{ text: takeawayPrompt }]
                    }];
        
                    // Make API call to Gemini
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
                    const payload = {
                        systemInstruction: {
                            parts: [{ text: `You are Bob, a professional business consultant. Generate a clear, well-structured conversation summary using Markdown formatting. Focus on clarity, professionalism, and readability.` }]
                        },
                        contents: tempHistory
                    };
        
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });
        
                    if (!response.ok) {
                        throw new Error(`API call failed with status ${response.status}`);
                    }
        
                    const result = await response.json();
                    const takeawaysText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        
                    // Remove loading indicator
                    chatArea.removeChild(loadingBubble);
        
                    if (takeawaysText) {
                        // Display the takeaways in the chat
                        createMessageBubble(takeawaysText, 'model');
            
                        // Optionally add to chat history
                        chatHistory.push({
                            role: "user",
                            parts: [{ text: "[Generated Takeaways Request]" }]
                        });
                        chatHistory.push({
                            role: "model",
                            parts: [{ text: takeawaysText }]
                        });
                    } else {
                        createMessageBubble('Sorry, I couldn\'t generate takeaways. Please try again.', 'model');
                    }
        
                } catch (error) {
                    // Remove loading indicator if still present
                    if (chatArea.contains(loadingBubble)) {
                        chatArea.removeChild(loadingBubble);
                    }
                    console.error('Error generating takeaways:', error);
                    createMessageBubble('An error occurred while generating takeaways. Please try again.', 'model');
                } finally {
                    // Re-enable the button
                    generateTakeawaysBtn.disabled = false;
                    generateTakeawaysBtn.textContent = originalButtonText;
                }
            });

                        
            // ===== WORKFLOW BUTTON HANDLERS =====
            
            const workflowBtn = document.getElementById('workflowBtn');
            const workflowMenu = document.getElementById('workflowMenu');
            
            if (workflowBtn && workflowMenu) {
                // Toggle workflow dropdown
                workflowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    workflowMenu.classList.toggle('hidden');
                    
                    // Close other dropdowns
                    const allMenus = [initialSetupMenu, analysisMenu, solutionDesignMenu, executionMenu, myPromptsMenu];
                    allMenus.forEach(menu => {
                        if (menu) menu.classList.add('hidden');
                    });
                });
                
                // Workflow option handlers
                document.querySelectorAll('.workflow-option').forEach(option => {
                    option.addEventListener('click', async () => {
                        const workflowKey = option.getAttribute('data-workflow');
                        workflowMenu.classList.add('hidden');
                        
                        // Ask for context
                        const context = prompt('Enter context for this workflow (e.g., "Tech Industry", "Coffee Shop Business", "SaaS Product"):');
                        
                        if (context !== null && context.trim() !== '') {
                            await executeWorkflow(workflowKey, context.trim());
                        } else if (context !== null) {
                            alert('Please provide context to run the workflow');
                        }
                    });
                });
                
                // Close workflow menu when clicking elsewhere
                document.addEventListener('click', (e) => {
                    if (!workflowBtn.contains(e.target) && !workflowMenu.contains(e.target)) {
                        workflowMenu.classList.add('hidden');
                    }
                });
            }

                        
            // ===== EXPORT BUTTON HANDLER =====
            
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    if (chatHistory.length <= 1) {
                        alert('No conversation to export yet!');
                        return;
                    }
                    
                    executeDocumentExport();
                    
                    // Show confirmation
                    createMessageBubble('âœ… Conversation exported successfully! Check your downloads folder.', 'model');
                });
            }
            
            
            // --- DROPDOWN TOGGLE LOGIC ---

            function toggleMenu(menuElement, buttonElement) {
                // Determine if any *other* menus are open and close them
                [initialSetupMenu, analysisMenu, solutionDesignMenu, executionMenu, myPromptsMenu].forEach(menu => {
                    if (menu !== menuElement) {
                        menu.classList.add('hidden');
                    }
                });
                // Toggle the current menu
                menuElement.classList.toggle('hidden');
            }
            // Click listeners for the main dropdown buttons
            initialSetupDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                toggleMenu(initialSetupMenu, initialSetupDropdownBtn);
            });
            analysisDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                toggleMenu(analysisMenu, analysisDropdownBtn);
            });
            solutionDesignDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                toggleMenu(solutionDesignMenu, solutionDesignDropdownBtn);
            });
            executionDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                toggleMenu(executionMenu, executionDropdownBtn);
            });
            // NEW: Listener for My Prompts
            myPromptsDropdownBtn.addEventListener('click', (e) => { // NEW CODE
                e.stopPropagation(); 
                toggleMenu(myPromptsMenu, myPromptsDropdownBtn);
            });
            
            // Listener to close menus when clicking anywhere else on the document (UPDATED)
            document.addEventListener('click', (e) => {
                // ADD myPromptsMenu to the array of menus
                const menus = [initialSetupMenu, analysisMenu, solutionDesignMenu, executionMenu, myPromptsMenu]; // CHANGED
                
                let clickedInsideMenu = false;
                for (const menu of menus) {
                    if (menu.contains(e.target)) {
                        clickedInsideMenu = true;
                        break;
                    }
                }
                if (!clickedInsideMenu) {
                    // If the click was not inside any menu, hide all menus
                    menus.forEach(menu => menu.classList.add('hidden'));
                }
            });
        })(); // End of IIFE
    </script>
</body>
</html>
